{"version":3,"file":"video-element-provider.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/providers/video-element-provider.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/providers/video-element-provider.ts\");\n","import type { ImplementedProvider, ProviderEvents, SeekRange } from '../../../../../src/js/providers/default';\nimport type Events from '../../../../../src/js/utils/backbone.events';\nimport type { InternalPlayerState } from '../../../../../src/js/events/events';\nimport type PlaylistItem from '../../../../../src/js/playlist/item';\nimport type { PlaylistItemSource } from '../../../../../src/js/playlist/source';\nimport type { QualityLevel } from '../../../../../src/js/providers/data-normalizer';\n\nconst jwplayer = window.jwplayer;\nconst PROVIDER_NAME = 'headless-video-element';\n\n// Provider events not implemented in the example:\n// \"bandwidthEstimate\" (We're letting the browser handle network activity here)\n// \"levelsChanged\" (also \"levels\" is just stubbed)\n// \"metadataCueParsed\" and \"meta\" events (emsg, id3, program-date-time...) (See html5.ts)\n// \"subtitlesTracks\" and \"subtitlesTrackChanged\" (See html5.ts and tracks-mixin)\n// \"audioTracks\" and \"audioTrackChanged\" (See html5.ts)\n\n// The ImplementedProvider interface matches internal providers\n// These changes reflect the interface required for any provider registered with jwplayer\ninterface CustomProvider extends Omit<ImplementedProvider,\n    'prototype'|'seeking'|'stallTime'|'instreamMode'|'renderNatively'|'supports'|'video'|\n    'getCurrentTime'|'getDuration'|'getSeekRange'|'getLiveLatency'|'setCurrentSubtitleTrack'|'setControls'|\n    'getBandwidthEstimate'|'isLive'> {\n    attachMedia(): void;\n    detachMedia(): void;\n}\n\ninterface VideoElementProvider {\n    // These methods are added in the constructor\n    // See src/js/utils/backbone.events.ts\n    on: CustomProvider['on'];\n    once: CustomProvider['once'];\n    off: CustomProvider['off'];\n    trigger: CustomProvider['trigger'];\n    // These 'DefaultProvider' methods are added to the prototype\n    // See src/js/providers/default.ts and src/js/providers/providers-register.ts\n    sendMediaType: (sources: Array<PlaylistItemSource>) => void;\n    setState: (state: InternalPlayerState) => void;\n}\n\ntype PlayerConfig = {\n    // Select an adaptation based on last bandwidthEstimate event from previous session\n    bandwidthEstimate: number | null,\n    // The user made a manual adaptation selection which had a bitrate of this value in the previous session\n    bitrateSelection: number | null\n}\n\nclass VideoElementProvider implements CustomProvider {\n\n    private static video?: HTMLVideoElement;\n\n    public name: string;\n    public state: InternalPlayerState;\n    public supportsPlaybackRate: boolean;\n    public container: HTMLDivElement | null;\n\n    private item: PlaylistItem;\n    private videoElement: HTMLVideoElement;\n    private config: { [key: string]: any };\n    private seeking: boolean;\n    private seekFromTime: number | null;\n    private seekToTime: number | null;\n    private stallTime: number | null;\n    private visualQuality: ProviderEvents['visualQuality'];\n    private readonly listenerDictionary: { [key: string]: any };\n\n    static supports(source: PlaylistItemSource): boolean {\n        if (source.type === 'custom-type') {\n            return true;\n        }\n        const video = VideoElementProvider.video = VideoElementProvider.video || document.createElement('video');\n        const mimeType = source.mimeType || {\n            aac: 'audio/mp4',\n            mp4: 'video/mp4',\n            f4v: 'video/mp4',\n            m4v: 'video/mp4',\n            mov: 'video/mp4',\n            mp3: 'audio/mpeg',\n            mpeg: 'audio/mpeg',\n            ogv: 'video/ogg',\n            ogg: 'video/ogg',\n            oga: 'video/ogg',\n            vorbis: 'video/ogg',\n            webm: 'video/webm',\n            f4a: 'video/aac',\n            m3u8: 'application/vnd.apple.mpegurl',\n            m3u: 'application/vnd.apple.mpegurl',\n            hls: 'application/vnd.apple.mpegurl'\n        }[source.type];\n        return !!(video && video.canPlayType && video.canPlayType(mimeType));\n    }\n\n    static getName(): { name: string } {\n        return {\n            name: PROVIDER_NAME\n        };\n    }\n\n    static isLive(duration) {\n        return duration === Infinity;\n    }\n\n    static isDvr(seekableDuration, minDvrWindow) {\n        return seekableDuration !== Infinity && Math.abs(seekableDuration) >= minDvrWindow;\n    }\n\n    constructor(playerId: string, config: PlayerConfig, mediaElement: HTMLVideoElement) {\n        // Add event listener methods used by the player to this instance\n        // See src/js/utils/backbone.events.ts\n        const backboneEvents: Events = jwplayer(playerId).Events;\n        Object.assign(this, backboneEvents);\n\n        // This video element comes from a pool managed by the player for dealing with autoplay policy\n        // and ads playback, but you could also use or create your own.\n        this.videoElement = mediaElement;\n\n        this.name = PROVIDER_NAME;\n        this.state = 'idle';\n        this.supportsPlaybackRate = true;\n        this.item = null;\n        this.container = null;\n        this.config = config;\n        this.seeking = false;\n        this.seekFromTime = null;\n        this.seekToTime = null;\n        this.stallTime = null;\n        this.videoElement.setAttribute('controls', '');\n        this.visualQuality = {\n            reason: 'initial choice',\n            mode: 'auto',\n            bitrate: 0,\n            level: {\n                width: 0,\n                height: 0,\n                index: 0,\n                label: ''\n            }\n        };\n\n        // Update state and trigger jwplayer events in response to changes on the video element\n        const videoEventCallbacks = {\n            click(this: VideoElementProvider, evt: Event) {\n                this.trigger('click', evt);\n            },\n            loadedmetadata(this: VideoElementProvider) {\n                this.trigger('meta', {\n                    metadataType: 'media',\n                    duration: this.getDuration(),\n                    height: this.videoElement.videoHeight,\n                    width: this.videoElement.videoWidth,\n                    seekRange: this.getSeekRange()\n                });\n            },\n            loadeddata(this: VideoElementProvider) {\n                if (this.videoElement.getStartDate) {\n                    // Get 'program-date-time' from this.videoElement.getStartDate() in Safari\n                }\n\n                // Get 'audioTracks' from this.videoElement.audioTracks;\n            },\n            durationchange(this: VideoElementProvider) {\n                this.listenerDictionary.progress.call(this);\n            },\n            canplay(this: VideoElementProvider) {\n                const mediaType = (this.videoElement.videoHeight === 0) ? 'audio' : 'video';\n                this.trigger('mediaType', { mediaType });\n                this.trigger('bufferFull');\n            },\n            play(this: VideoElementProvider) {\n                if (!this.videoElement.paused && this.state !== 'playing') {\n                    this.setState('loading');\n                }\n            },\n            playing(this: VideoElementProvider) {\n                this.trigger('providerFirstFrame');\n                this.setState('playing');\n            },\n            pause(this: VideoElementProvider) {\n                if (this.state === 'complete' ||\n                    this.videoElement.ended ||\n                    this.videoElement.error ||\n                    this.videoElement.currentTime === this.videoElement.duration) {\n                    return;\n                }\n                this.setState('paused');\n            },\n            timeupdate(this: VideoElementProvider) {\n                const duration = this.getDuration();\n                if (isNaN(duration)) {\n                    return;\n                }\n                const currentTime = this.videoElement.currentTime;\n                if (!this.seeking && !this.videoElement.paused &&\n                    (this.state === 'stalled' || this.state === 'loading') &&\n                    this.stallTime !== currentTime) {\n                    this.stallTime = -1;\n                    this.listenerDictionary.playing.call(this);\n                }\n                const position = this.getCurrentTime();\n                const seekRange = this.getSeekRange();\n                const timeEvent: ProviderEvents['time'] = {\n                    position,\n                    duration,\n                    currentTime,\n                    seekRange,\n                    metadata: {\n                        currentTime\n                    }\n                };\n                const latency = this.getLiveLatency();\n                if (latency !== null) {\n                    timeEvent.latency = latency;\n                }\n\n                if (this.seekToTime === null) {\n                    this.seekFromTime = currentTime;\n                }\n                // only emit time events when playing or seeking\n                if (this.state === 'playing' || this.seeking) {\n                    this.trigger('time', timeEvent);\n                }\n            },\n            ratechange(this: VideoElementProvider) {\n                this.trigger('ratechange', { playbackRate: this.videoElement.playbackRate });\n            },\n            seeking(this: VideoElementProvider) {\n                const offset = this.seekToTime !== null ? this.timeToPosition(this.seekToTime) : this.getCurrentTime();\n                const position = this.timeToPosition(this.seekFromTime || 0);\n                this.seekFromTime = this.seekToTime;\n                this.seekToTime = null;\n                this.seeking = true;\n                this.trigger('seek', {\n                    position,\n                    offset\n                });\n            },\n            seeked(this: VideoElementProvider) {\n                if (!this.seeking) {\n                    return;\n                }\n                this.seeking = false;\n                this.trigger('seeked');\n            },\n            progress(this: VideoElementProvider) {\n                const duration = this.getDuration();\n                const buffered = this.videoElement.buffered;\n                if (duration <= 0 || duration === Infinity || !buffered || buffered.length === 0) {\n                    return;\n                }\n                const bufferPercent = 100 * Math.min(Math.max(buffered.end(buffered.length - 1) / duration, 0), 1);\n                this.trigger('bufferChange', {\n                    bufferPercent,\n                    position: this.getCurrentTime(),\n                    duration,\n                    currentTime: this.videoElement.currentTime,\n                    seekRange: this.getSeekRange()\n                });\n            },\n            waiting(this: VideoElementProvider) {\n                if (this.seeking) {\n                    this.setState('loading');\n                } else if (this.state === 'playing') {\n                    if (this.atEdgeOfLiveStream()) {\n                        this.setPlaybackRate(1);\n                    }\n                    this.stallTime = this.videoElement.currentTime;\n                    this.setState('stalled');\n                }\n            },\n            resize(this: VideoElementProvider) {\n                const { videoElement } = this;\n                const { videoWidth, videoHeight } = videoElement;\n                // Trigger 'visualQuality' when videoWidth or videoHeight changes\n                const level = this.visualQuality.level;\n                if (level.width !== videoWidth || level.height !== videoHeight) {\n                    const visualQuality: ProviderEvents['visualQuality'] = {\n                        level: {\n                            width: videoWidth,\n                            height: videoHeight,\n                            index: 0, // TODO: level index\n                            label: '' // TODO: levels\n                        },\n                        bitrate: 0,\n                        mode: 'auto', // TODO: 'manual' for mp4 levels\n                        reason: 'auto', // TODO: 'initial choice' for first resize after loading new item\n                    };\n                    this.visualQuality = visualQuality;\n                    this.trigger('visualQuality', visualQuality);\n                }\n            },\n            volumechange(this: VideoElementProvider) {\n                this.trigger('volume', {\n                    volume: Math.round(this.videoElement.volume * 100)\n                });\n\n                this.trigger('mute', {\n                    mute: this.videoElement.muted\n                });\n            },\n            ended(this: VideoElementProvider) {\n                if (this.state !== 'idle' && this.state !== 'complete') {\n                    this.trigger('complete');\n                }\n            },\n            error(this: VideoElementProvider, sourceError) {\n                this.videoElement.removeAttribute('src');\n                this.videoElement.load();\n                const error = {\n                    code: 290000, // Unknown Provider Error\n                    sourceError\n                };\n                this.trigger('mediaError', error);\n            }\n        };\n\n        this.listenerDictionary = {};\n        Object.keys(videoEventCallbacks).forEach(eventName => {\n            this.listenerDictionary[eventName] = videoEventCallbacks[eventName].bind(this);\n        });\n    }\n\n    getName(): { name: string } {\n        return VideoElementProvider.getName();\n    }\n\n    attachMedia(): void {\n        this.seeking = false;\n        this.seekFromTime = null;\n        this.seekToTime = null;\n        // Reset video element settings\n        this.videoElement.loop = false;\n        // Add video element event listeners\n        const listenerDictionary = this.listenerDictionary;\n        Object.keys(listenerDictionary).forEach(eventName => {\n            this.videoElement.removeEventListener(eventName, listenerDictionary[eventName]);\n            this.videoElement.addEventListener(eventName, listenerDictionary[eventName]);\n        });\n    }\n\n    detachMedia(): void {\n        if (!this.videoElement) {\n            return;\n        }\n        const listenerDictionary = this.listenerDictionary;\n        Object.keys(listenerDictionary).forEach(eventName => {\n            this.videoElement.removeEventListener(eventName, listenerDictionary[eventName]);\n        });\n    }\n\n    init(item: PlaylistItem): void {\n        this.item = item;\n        this.state = 'idle';\n        this.attachMedia();\n    }\n\n    preload(item: PlaylistItem): void {\n        this.item = item;\n        // TODO: convert sources array to \"levels\"\n        if (item.image) {\n            this.videoElement.setAttribute('poster', item.image);\n        }\n        this.setVideoSource(item.sources[0]);\n        this.videoElement.load();\n    }\n\n    load(item: PlaylistItem): void {\n        // TODO: Load side loaded item.tracks\n\n        this.item = item;\n        const previousSource = this.videoElement.src;\n        this.setVideoSource(item.sources[0]);\n        const sourceChanged = previousSource !== this.videoElement.src;\n        if (sourceChanged) {\n            // Do not call load if src was not set. load() will cancel any active play promise.\n            if (previousSource) {\n                this.videoElement.load();\n            }\n        } else if (item.starttime === 0 && this.videoElement.currentTime > 0) {\n            // Load event is from the same video as before\n            // restart video without dispatching seek event\n            this.seek(item.starttime);\n        }\n\n        // Check if we have already seeked the mediaElement before _completeLoad has been called\n        if (item.starttime > 0 && this.videoElement.currentTime !== item.starttime) {\n            this.seek(item.starttime);\n        }\n\n        // TODO: convert sources array to \"levels\"\n        this.trigger('levels', {\n            levels: [{\n                label: '0'\n            }],\n            currentQuality: 0\n        });\n    }\n\n    volume(vol: number): void {\n        this.videoElement.volume = Math.min(Math.max(0, vol / 100), 1);\n    }\n\n    mute(state: string): void {\n        this.videoElement.muted = !!state;\n    }\n\n    resize(width: number, height: number, stretching: string): void {\n        const { videoWidth, videoHeight } = this.videoElement;\n        if (!width || !height || !videoWidth || !videoHeight) {\n            return;\n        }\n        this.videoElement.style.objectFit = '';\n        if (stretching === 'uniform') {\n            // Snap video to edges when the difference in aspect ratio is less than 9% and perceivable\n            const playerAspectRatio = width / height;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const edgeMatch = Math.abs(playerAspectRatio - videoAspectRatio);\n            if (edgeMatch < 0.09 && edgeMatch > 0.0025) {\n                this.videoElement.style.objectFit = 'fill';\n            }\n        }\n    }\n\n    getContainer(): HTMLDivElement | null {\n        return this.container;\n    }\n\n    setContainer(element: HTMLDivElement): void {\n        this.container = element;\n        if (element && this.videoElement.parentNode !== element) {\n            element.appendChild(this.videoElement);\n        }\n    }\n\n    removeFromContainer(): void {\n        const { container, videoElement } = this;\n        this.container = null;\n        if (container && container === videoElement.parentNode) {\n            container.removeChild(videoElement);\n        }\n    }\n\n    public remove(): void {\n        const container = this.container;\n        const video = this.videoElement;\n        this.stop();\n        this.destroy();\n        if (container) {\n            container.removeChild(video);\n        }\n    }\n\n    public stop(): void {\n        this.seeking = false;\n        if (this.videoElement) {\n            this.videoElement.removeAttribute('preload');\n            this.videoElement.removeAttribute('src');\n            this.videoElement.load();\n        }\n        this.setState('idle');\n    }\n\n    public destroy(): void {\n        this.off();\n        this.detachMedia();\n        this.item = null;\n        this.seeking = false;\n        this.container = null;\n        // @ts-ignore\n        this.config = null;\n        // @ts-ignore\n        this.videoElement = null;\n    }\n\n    public supportsFullscreen(): boolean {\n        return true;\n    }\n\n    public setVisibility(state): void {\n        state = !!state;\n        if (this.container) {\n            this.container.style.opacity = state ? '1' : '0';\n        }\n    }\n\n    public play(): Promise<void> {\n        return this.videoElement.play();\n    }\n\n    public pause(): void {\n        this.videoElement.pause();\n    }\n\n    public seek(toPosition: number) {\n        const seekRange = this.getSeekRange();\n        if (toPosition < 0) {\n            this.seekToTime = toPosition + seekRange.end;\n        } else {\n            this.seekToTime = toPosition;\n        }\n        if (!this.getSeekableEnd()) {\n            // Can't seek without seekable range, trigger playback\n            // TODO: Defer seeking until seekable range updates\n            this.item.starttime = this.seekToTime;\n            this.play();\n            return;\n        }\n\n        this.seeking = true;\n        this.seekFromTime = this.videoElement.currentTime;\n        this.videoElement.currentTime = this.seekToTime;\n    }\n\n    public getPlaybackRate(): number {\n        return this.videoElement.playbackRate;\n    }\n\n    public setPlaybackRate(playbackRate: number) {\n        this.videoElement.playbackRate = this.videoElement.defaultPlaybackRate = playbackRate;\n    }\n\n    public getCurrentQuality(): number {\n        return 0;\n    }\n\n    public setCurrentQuality(qualityLevel: number): void {\n    }\n\n    public getQualityLevels(): QualityLevel[] {\n        return [{\n            bitrate: 0,\n            label: '0',\n            width: this.videoElement.videoWidth,\n            height: this.videoElement.videoHeight\n        }];\n    }\n\n    public setCurrentAudioTrack(at: number): void {\n    }\n\n    public getCurrentAudioTrack(): number {\n        return 0;\n    }\n    public getAudioTracks(): { name: string, language: string }[] {\n        return [];\n    }\n\n    public getFullscreen(): boolean {\n        // Only return true if the video element itself is fullscreen (not the app/page/player)\n        return false;\n    }\n\n    public setFullscreen(isFullscreen: boolean): void {\n        // Request for the video element to go fullscreen, because the player is unable (iOS)\n    }\n\n    private getCurrentTime(): number {\n        const currentTime = this.videoElement.currentTime;\n        const seekRange = this.getSeekRange();\n        if (VideoElementProvider.isLive(this.videoElement.duration)) {\n            if (VideoElementProvider.isDvr(seekRange.end - seekRange.start, Math.max(this.config.minDvrWindow, 30))) {\n                return currentTime - seekRange.end;\n            }\n        }\n        return currentTime;\n    }\n\n    private getDuration(): number {\n        let duration = this.videoElement.duration;\n        // Don't sent time event on Android before real duration is known\n        if (isNaN(duration)) {\n            return 0;\n        }\n        const end = this.getSeekableEnd();\n        if (VideoElementProvider.isLive(this.videoElement.duration) && end) {\n            const seekableDuration = end - this.getSeekableStart();\n            if (VideoElementProvider.isDvr(seekableDuration, Math.max(this.config.minDvrWindow, 30))) {\n                // Player interprets negative duration as DVR\n                duration = -seekableDuration;\n            }\n        }\n        return duration;\n    }\n\n    private getSeekRange(): SeekRange {\n        const seekRange: SeekRange = {\n            start: 0,\n            end: 0\n        };\n        const seekable = this.videoElement.seekable;\n        if (seekable.length) {\n            seekRange.end = this.getSeekableEnd();\n            seekRange.start = this.getSeekableStart();\n        } else if (isFinite(this.videoElement.duration)) {\n            seekRange.end = this.videoElement.duration;\n        }\n        return seekRange;\n    }\n\n    private getSeekableStart(): number {\n        let start = Infinity;\n        ['buffered', 'seekable'].forEach(range => {\n            const timeRange = this.videoElement[range];\n            let index = timeRange ? timeRange.length : 0;\n            while (index--) {\n                const rangeStart = Math.min(start, timeRange.start(index));\n                if (isFinite(rangeStart)) {\n                    start = rangeStart;\n                }\n            }\n        });\n        return start;\n    }\n\n    private getSeekableEnd(): number {\n        let end = 0;\n        ['buffered', 'seekable'].forEach(range => {\n            const timeRange = this.videoElement[range];\n            let index = timeRange ? timeRange.length : 0;\n            while (index--) {\n                const rangeEnd = Math.max(end, timeRange.end(index));\n                if (isFinite(rangeEnd)) {\n                    end = rangeEnd;\n                }\n            }\n        });\n        return end;\n    }\n\n    private timeToPosition(time: number): number {\n        if (VideoElementProvider.isLive(this.videoElement.duration)) {\n            const seekRange = this.getSeekRange();\n            if (VideoElementProvider.isDvr(seekRange.end - seekRange.start, Math.max(this.config.minDvrWindow, 30))) {\n                return Math.min(0, time - seekRange.end);\n            }\n        }\n        return time;\n    }\n\n    private atEdgeOfLiveStream(): boolean {\n        if (!VideoElementProvider.isLive(this.videoElement.duration)) {\n            return false;\n        }\n        // currentTime doesn't always get to the end of the buffered range\n        const timeFudge = 2;\n        const buffered = this.videoElement.buffered;\n        const endOfRange = (buffered && buffered.length) ? buffered.end(buffered.length - 1) : 0;\n        return (endOfRange - this.videoElement.currentTime) <= timeFudge;\n    }\n\n    private getLiveLatency(): number | null {\n        let latency: number | null = null;\n        const end = this.getSeekableEnd();\n        if (VideoElementProvider.isLive(this.videoElement.duration) && end) {\n            latency = end - this.videoElement.currentTime;\n        }\n        return latency;\n    }\n\n    private setVideoSource(source): void {\n        const preload = source.preload || 'metadata';\n        if (this.videoElement.getAttribute('preload') !== preload) {\n            this.videoElement.setAttribute('preload', preload);\n        }\n        const sourceElement = document.createElement('source');\n        sourceElement.src = source.file;\n        const sourceChanged = (this.videoElement.src !== sourceElement.src);\n        if (sourceChanged) {\n            this.videoElement.src = source.file;\n        }\n    }\n}\n\njwplayer.api.registerProvider(VideoElementProvider);\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3EA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA4BA;AAmBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AALA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AALA;AAMA;AACA;AAAA;AACA;AACA;AAVA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAFA;AAIA;AACA;AA5KA;AA+KA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAEA;;;;A","sourceRoot":""}